{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Image Retrieval\"\n",
        "date: today\n",
        "date-format: long\n",
        "author: \"Steven  Ndung'u et al.\"\n",
        "format:\n",
        "  html:\n",
        "    toc: true\n",
        "    toc-depth: 3\n",
        "    toc-location: left\n",
        "    page-layout: full\n",
        "    theme:\n",
        "          light: flatly\n",
        "          dark: darkly\n",
        "    number-sections: false\n",
        "    highlighting: true\n",
        "    smooth-scroll: true\n",
        "    code-fold: true\n",
        "    highlighting-style: GitHub\n",
        "    self-contained: true\n",
        "execute:\n",
        "    echo: true\n",
        "    warning: false\n",
        "    enable: true\n",
        "\n",
        "title-block-banner: true\n",
        "\n",
        "---\n",
        "\n",
        "```{=html}\n",
        "<style type=\"text/css\">\n",
        "\n",
        "h1.title {\n",
        "  font-size: 20px;\n",
        "  color: White;\n",
        "  text-align: center;\n",
        "}\n",
        "h4.author { /* Header 4 - and the author and data headers use this too  */\n",
        "    font-size: 16px;\n",
        "  font-family: \"Source Sans Pro Semibold\", Times, serif;\n",
        "  color: Red;\n",
        "  text-align: center;\n",
        "}\n",
        "h4.date { /* Header 4 - and the author and data headers use this too  */\n",
        "  font-size: 16px;\n",
        "  font-family: \"Source Sans Pro Semibold\", Times, serif;\n",
        "  color: Red;\n",
        "  text-align: center;\n",
        "}\n",
        "</style>\n",
        "```\n",
        "\n",
        "\n",
        "------------------------------------------------------------------------\n",
        ":::{.column-page}\n",
        "\n",
        "::: {style=\"text-align:center\"}\n",
        "<h2>Model Evaluation COSFIRE Filters Approach</h2>\n",
        ":::\n",
        "\n",
        "</br>\n",
        "\n",
        "# Introduction\n",
        "\n",
        "\n",
        "We obtain the 26 statistically significant sets of hyperparameters from the classification paper along with their respective training, validation, and test descriptors. Based on these descriptors, we perform image hashing for each set of descriptors using a selected set of MLP hyperparameters (for the grid search). \n"
      ],
      "id": "b53b6dcd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "#| \n",
        "###################################################\n",
        "# Experiment 1\n",
        "###################################################\n",
        "#$Env:QUARTO_PYTHON = \"C:\\Users\\P307791\\Anaconda3\\python.exe\"\n",
        "import os\n",
        "os.environ['PYTHONHASHSEED'] = 'python'\n",
        "from scipy import stats\n",
        "\n",
        "from IPython.display import display, Markdown, HTML\n",
        "from itables import init_notebook_mode\n",
        "init_notebook_mode(all_interactive=True)\n",
        "from itables import show\n",
        "\n",
        "import torch.nn as nn\n",
        "\n",
        "import plotly.express as px\n",
        "import pandas as pd\n",
        "import plotly.graph_objects as go\n",
        "import plotly.io as pio\n",
        "pio.renderers.default = \"notebook\"\n",
        "\n",
        "import pandas as pd\n",
        "import numpy as np\n",
        "import re\n",
        "from scipy import stats\n",
        "\n",
        "import seaborn as sns\n",
        "import matplotlib.pyplot as plt\n",
        "\n",
        "\n",
        "def find_max(row):\n",
        "    return row.max()\n",
        "\n",
        "\n",
        "def colsum(x):\n",
        "    return sum(np.isnan(x))\n",
        "\n",
        "layer_vsn = 'v3_layers_v2'\n",
        "# l1_reg_values = [0,0.0001, 0.00001, 1e-8]\n",
        "# l2_reg_values = [0,0.0001, 0.00001, 1e-8]\n",
        "\n",
        "l1_reg_values = [0,1e-8]\n",
        "l2_reg_values = [0,1e-8]\n",
        "\n",
        "query = (\n",
        "    \"output_size == @output_size and \"\n",
        "    \"l1_reg in @l1_reg_values and \"\n",
        "    \"l2_reg in @l2_reg_values\"\n",
        ")\n"
      ],
      "id": "4607b7a7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The outputs below represent an example of a single experiment based on an array of hyperparameters considered to determine the optimal configuration of the MLP hashing architecture (For bit size 32).\n",
        "\n",
        "::: {.panel-tabset}\n",
        "\n",
        "## Model structure\n",
        "\n",
        "![](hyperparameter_range.png)\n"
      ],
      "id": "39534908"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: true\n",
        "#| output: true\n",
        "#| code-fold: true\n",
        "\n",
        "class CosfireNet(nn.Module):\n",
        "    def __init__(self, input_size, bitsize, l1_reg, l2_reg):\n",
        "        super(CosfireNet, self).__init__()\n",
        "        self.l1_reg = l1_reg\n",
        "        self.l2_reg = l2_reg\n",
        "        self.hd = nn.Sequential(\n",
        "            nn.Linear(input_size, 300),\n",
        "            nn.BatchNorm1d(300),\n",
        "            nn.Tanh(),\n",
        "            nn.Linear(300, 200),\n",
        "            nn.BatchNorm1d(200),\n",
        "            nn.Tanh(),\n",
        "            nn.Linear(200, bitsize),\n",
        "            nn.Tanh()\n",
        "        )\n",
        "    def forward(self, x):\n",
        "        regularization_loss = 0.0\n",
        "        for param in self.hd.parameters():\n",
        "            regularization_loss += torch.sum(torch.abs(param)) * self.l1_reg  # L1 regularization\n",
        "            regularization_loss += torch.sum(param ** 2) * self.l2_reg  # L2 regularization\n",
        "        return self.hd(x), regularization_loss"
      ],
      "id": "c3afc8fb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Density plots\n",
        "\n",
        "![](density_plot_24062024.png)\n",
        "\n",
        "## mAP Curves\n",
        "\n",
        "![](Maps_curves_abs_values_24062024.png)\n",
        "\n",
        "## T-SNE_projection plots\n",
        "\n",
        "![](T-SNE_projection_24062024.png)\n",
        "\n",
        "## Loss curves\n",
        "::: {.column-screen layout-ncol=2}\n",
        "\n",
        "![Without regularization](Train_valid_curves.png)\n",
        "\n",
        "![With regularization](Train_valid_curves_random.png)\n",
        "\n",
        ":::\n",
        "\n",
        ":::\n",
        "\n",
        "\n",
        "::: {.callout-tip}\n",
        "\n",
        "tiply, each row represents a unique combination of MLP hyperparameters, and every column represents the results yielded by each of the 26 statistically significant sets of descriptors. \n",
        "\n",
        ":::\n",
        "\n",
        "</br>\n",
        "\n",
        "::: {.panel-tabset}\n",
        "\n",
        "\n",
        "In these experiments, we have considered four different bit sizes.\n",
        "\n",
        "\n",
        "##  Bit size 32\n",
        "\n",
        "\n",
        "The results in this presentation are from two experimental designs:\n",
        "\n",
        "::: {.panel-tabset}\n",
        "\n",
        "###  Experiment 1 Results\n",
        "\n",
        "The thresholding is based on fixed values between -1 and 1 on a step size of 0.1.\n",
        "\n",
        "\n",
        "\n",
        "::: {.panel-tabset}\n"
      ],
      "id": "1399cf92"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#%%\n",
        "\n",
        "dt_valid  = pd.read_csv(f\"descriptors_tain_valid_test/v3_layers_v2/merged_validation_runs_wide_format_abs_13062024_{layer_vsn}.csv\")\n",
        "\n",
        "\n",
        "dt_test  = pd.read_csv(f\"descriptors_tain_valid_test/v3_layers_v2/merged_test_runs_wide_format_abs_13062024_{layer_vsn}.csv\")\n",
        "\n",
        "\n",
        "\n",
        "output_size = 32\n",
        "\n",
        "\n",
        "dt_valid = dt_valid.query(query)\n",
        "\n",
        "dt_test = dt_test.query(query)"
      ],
      "id": "e81345d1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### Validation Data mAP Results Preview:\n"
      ],
      "id": "a7d20e9e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "#| \n",
        "html_table = dt_valid.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))"
      ],
      "id": "7d40c495",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "</br>\n",
        "\n",
        "#### Test Data mAP Results Preview:\n"
      ],
      "id": "ae966e8a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "#| \n",
        "html_table = dt_test.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))"
      ],
      "id": "085d5550",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {.panel-tabset}\n",
        "\n",
        "</br>\n",
        "\n",
        "The global mean maximum row:\n"
      ],
      "id": "6fe158f0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "################\n",
        "dt_valid_sub = dt_valid[list(dt_valid.columns[dt_valid.columns.str.startswith('mAP_valid')])]\n",
        "\n",
        "# Apply the function row-wise\n",
        "dt_valid_sub['average_map'] = dt_valid_sub.apply(np.mean, axis=1)\n",
        "dt_valid_sub.sort_values(by='average_map', ascending=False, inplace=True)\n",
        "\n",
        "#maximum mean value\n",
        "dt_valid_sub['average_map'].max()\n",
        "\n",
        "\n",
        "\n",
        "#########\n",
        "\n",
        "\n",
        "# extract max value row.\n",
        "\n",
        "max_index = dt_valid_sub['average_map'].idxmax()\n",
        "max_row = dt_valid_sub.loc[max_index]\n",
        "#print(max_row)\n",
        "dt_valid_sub_mw = dt_valid_sub.copy()"
      ],
      "id": "f679f514",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "dd = dt_valid_sub.head(1)\n",
        "\n",
        "html_table = dd.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 100px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))"
      ],
      "id": "817b9e0d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### Model performance on validation data (T-test)\n",
        "\n",
        "\n",
        "\n",
        "##### Statistical Significance:\n",
        "\n",
        "\n",
        "Using the global mean maximum row as the reference, we perform the right-tailed t-test to identify significant hyperparameters.\n"
      ],
      "id": "797d332d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pvalues = []\n",
        "pvalues_real = []\n",
        "\n",
        "for _,index in enumerate(dt_valid_sub.index):\n",
        "  _, p_value = stats.ttest_ind(max_row[:-1], dt_valid_sub.loc[index][:-1], alternative='greater')\n",
        "  pvalues_real.append(p_value)\n",
        "  pvalues.append((p_value >= 0.05)*1)\n",
        "\n",
        "  \n",
        "\n",
        "dt_valid_sub['pvalues'] = pvalues_real\n",
        "dt_valid_sub['sig'] = pvalues\n",
        "\n",
        "\n",
        "dt_valid_sub1 = dt_valid_sub.query('sig == 1')\n",
        "\n",
        "\n",
        "max_indexx = dt_valid_sub1.iloc[:, :-3].mean().idxmax()\n",
        "\n",
        "#print(sum(pvalues),max_indexx)"
      ],
      "id": "a844b0d7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "dt = dt_valid.loc[dt_valid_sub1.index].sort_values(by = ['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "html_table = dt.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "\n",
        "print('Size of the All data: ',dt_valid_sub.shape)\n",
        "\n",
        "print('Size of the Sig data: ',dt_valid_sub1.shape)"
      ],
      "id": "3162c95a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "####################################################\n",
        "# Use the hyperparameters to the test data.\n",
        "####################################################\n",
        "optimal_params1 = dt_valid.loc[dt_valid_sub1.index][['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg']]\n",
        "optimal_params = optimal_params1.reset_index()\n",
        "optimal_params.drop(['index'], axis=1, inplace = True)\n",
        "\n",
        "#rotation invariance test data with optimal parameters\n",
        "test_data_1 = pd.merge(optimal_params, dt_test, on=['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "test_data_1_sub = test_data_1[list(test_data_1.columns[test_data_1.columns.str.startswith('mAP_test')])]"
      ],
      "id": "bef62d33",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Equivalent test data\n"
      ],
      "id": "2163f1ea"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "test_data_1 = test_data_1.sort_values(by = ['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "html_table = test_data_1.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "print('Size of the test data: ',test_data_1.shape)"
      ],
      "id": "ae52ecbb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Difference\n"
      ],
      "id": "78d0b23d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "diff = dt[['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg']]\n",
        "for i, cols in enumerate(zip(dt.columns,test_data_1.columns)):   \n",
        "   diff[f'col_diff_{i}'] = (np.array(dt[cols[0]]) - np.array(test_data_1[cols[1]]))*-1\n",
        "\n",
        "# Function to count negatives in a row\n",
        "def count_negatives(row):\n",
        "    return sum(1 for value in row if isinstance(value, (int, float)) and value < 0)\n",
        "\n",
        "diff['negative_count'] = diff.apply(count_negatives, axis=1)\n",
        "diff.sort_values(by =[\"negative_count\"],inplace = True, ascending=False)\n",
        "\n",
        "html_table = diff.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "\n",
        "# \n",
        "# show(diff)"
      ],
      "id": "1d92ea91",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.panel-tabset}\n",
        "\n",
        "##### Model performance on valid data\n",
        "\n",
        "Average & Std Deviation of the Significant rows:\n"
      ],
      "id": "721b4299"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "res = dt_valid_sub1.iloc[:,:-3].describe().iloc[1:3]\n",
        "\n",
        "res_valid1 = res.T.sort_values(by=['mean'], ascending= False)\n",
        "\n",
        "html_table = res_valid1.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n"
      ],
      "id": "a2836462",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##### Model performance on Test data\n",
        "</br>\n",
        "We then apply the hyperparameters to the test set and average the results.\n"
      ],
      "id": "60a0541d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "test_data_1['average_map'] = test_data_1_sub.apply(np.mean, axis=1)\n",
        "\n",
        "test_data_1.sort_values(by=['average_map'], ascending= False,inplace=True)"
      ],
      "id": "3a972402",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "res = test_data_1.describe().iloc[1:3][list(test_data_1.columns[test_data_1.columns.str.startswith('mAP_test')])+ ['average_map']]\n",
        "\n",
        "res_test1 = res.T.sort_values(by=['mean'], ascending= False)\n",
        "\n",
        "html_table = res_test1.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n"
      ],
      "id": "9e515026",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "#### Model performance on validation data (Mann-Whitney U Test)\n",
        "\n",
        "##### Statistical Significance:\n",
        "\n",
        "\n",
        "Using the global mean maximum row as the reference, we perform the right-tailed t-test to identify significant hyperparameters.\n"
      ],
      "id": "8e9f4af2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pvalues_mw = []\n",
        "pvalues_real_mw = []\n",
        "\n",
        "for _,index in enumerate(dt_valid_sub.index):\n",
        "\n",
        "  _, p_value_mw = stats.mannwhitneyu(max_row[:-1], dt_valid_sub.loc[index][:-1], alternative='greater')#, method = 'asymptotic')\n",
        "  pvalues_real_mw.append(p_value_mw)\n",
        "  pvalues_mw.append((p_value_mw >= 0.05)*1)\n",
        "  \n",
        "\n",
        "dt_valid_sub_mw['pvalues_mw'] = pvalues_real_mw\n",
        "dt_valid_sub_mw['sig_mw'] = pvalues_mw\n",
        "\n",
        "dt_valid_sub_mw1 = dt_valid_sub_mw.query('sig_mw == 1')\n",
        "\n",
        "\n",
        "max_indexx = dt_valid_sub_mw1.iloc[:, :-3].mean().idxmax()\n",
        "\n",
        "#print(sum(pvalues),max_indexx)"
      ],
      "id": "5042f881",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "\n",
        "dt_mw = dt_valid.loc[dt_valid_sub_mw1.index].sort_values(by = ['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "html_table = dt_mw.to_html(index=True)\n",
        "\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "\n",
        "print('Size of the All data: ',dt_valid_sub_mw.shape)\n",
        "\n",
        "print('Size of the Sig data: ',dt_mw.shape)"
      ],
      "id": "9288d949",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "####################################################\n",
        "# Use the hyperparameters to the test data.\n",
        "####################################################\n",
        "optimal_params_mw1 = dt_valid.loc[dt_valid_sub_mw1.index][['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg']]\n",
        "optimal_params_mw = optimal_params_mw1.reset_index()\n",
        "optimal_params_mw.drop(['index'], axis=1, inplace = True)\n",
        "\n",
        "#rotation invariance test data with optimal parameters\n",
        "test_data_mw1 = pd.merge(optimal_params_mw, dt_test, on=['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "test_data_1_sub_mw = test_data_mw1[list(test_data_mw1.columns[test_data_mw1.columns.str.startswith('mAP_test')])]"
      ],
      "id": "b507b096",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Equivalent test data\n"
      ],
      "id": "3fc6ffd3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "test_data_mw1 = test_data_mw1.sort_values(by = ['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "html_table = test_data_mw1.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "print('Size of the test data: ',test_data_mw1.shape)"
      ],
      "id": "55f56032",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Difference\n"
      ],
      "id": "ecc03e40"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "diff_mw = dt_mw[['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg']]\n",
        "for i, cols in enumerate(zip(dt_mw.columns,test_data_mw1.columns)):   \n",
        "   diff_mw[f'col_diff_{i}'] = (np.array(dt_mw[cols[0]]) - np.array(test_data_mw1[cols[1]]))*-1\n",
        "\n",
        "# Function to count negatives in a row\n",
        "def count_negatives(row):\n",
        "    return sum(1 for value in row if isinstance(value, (int, float)) and value < 0)\n",
        "\n",
        "diff_mw['negative_count'] = diff_mw.apply(count_negatives, axis=1)\n",
        "\n",
        "diff_mw.sort_values(by =[\"negative_count\"],inplace = True, ascending=False)\n",
        "\n",
        "\n",
        "html_table = diff_mw.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "\n",
        "key_values = ['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg']\n",
        "print('Are the keys of the valid and test dfs same?: ',dt_mw[key_values].equals(test_data_mw1[key_values]))"
      ],
      "id": "836e5a8e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "\n",
        "# Function to count negatives in a row\n",
        "def count_negatives(row):\n",
        "    return sum(1 for value in row if isinstance(value, (int, float)) and value < 0)\n",
        "\n",
        "diff_mw['negative_count'] = diff_mw.apply(count_negatives, axis=1)\n",
        "# show(diff)"
      ],
      "id": "e8ef7711",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.panel-tabset}\n",
        "\n",
        "##### Model performance on valid data \n",
        "\n",
        "Average & Std Deviation of the Significant rows:\n"
      ],
      "id": "334e09ad"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "res = dt_valid_sub_mw1.iloc[:,:-3].describe().iloc[1:3]\n",
        "\n",
        "res_valid2 = res.T.sort_values(by=['mean'], ascending= False)\n",
        "\n",
        "html_table = res_valid2.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n"
      ],
      "id": "d96b1e96",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##### Model performance on Test data \n",
        "</br>\n",
        "We then apply the hyperparameters to the test set and average the results.\n"
      ],
      "id": "130fd3ec"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "####################################################\n",
        "# Use the hyperparameters to the test data.\n",
        "####################################################\n",
        "optimal_params = dt_valid.loc[dt_valid_sub_mw1.index].iloc[:, :6].reset_index()\n",
        "optimal_params.drop(['index'], axis=1, inplace = True)\n",
        "\n",
        "#rotation invariance test data with optimal parameters\n",
        "test_data_1 = pd.merge(optimal_params, dt_test, how='left')\n",
        "test_data_1_sub = test_data_1[list(test_data_1.columns[test_data_1.columns.str.startswith('mAP_test')])]\n",
        "test_data_1['average_map'] = test_data_1_sub.apply(np.mean, axis=1)\n",
        "\n",
        "test_data_1.sort_values(by=['average_map'], ascending= False,inplace=True)"
      ],
      "id": "ba75dce4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "res = test_data_1.describe().iloc[1:3][list(test_data_1.columns[test_data_1.columns.str.startswith('mAP_test')]) + ['average_map']]\n",
        "\n",
        "res_test2 = res.T.sort_values(by=['mean'], ascending= False)\n",
        "\n",
        "html_table = res_test2.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))"
      ],
      "id": "f69aa3e7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        ":::\n",
        "\n",
        "</br>\n",
        "\n",
        "\n",
        "Summary using radar plot\n"
      ],
      "id": "258313ad"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| layout-ncol: 2\n",
        "#| \n",
        "def extract_number(text):\n",
        "    if isinstance(text, str):\n",
        "        matches = re.findall(r'\\d+', text)\n",
        "        return int(matches[0]) if matches else 1\n",
        "    return 1\n",
        "\n",
        "res_valid1['id'] = res_valid1.index.to_series().apply(extract_number)\n",
        "res_test1['id'] = res_test1.index.to_series().apply(extract_number)\n",
        "\n",
        "\n",
        "\n",
        "res_comb = pd.concat([res_valid1,res_test1])\n",
        "index_series = res_comb.index.to_series()\n",
        "\n",
        "res_comb['type'] = np.where(\n",
        "    index_series.str.contains('valid', case=False), 'valid',\n",
        "    np.where(index_series.str.contains('test', case=False), 'test', 'unknown')\n",
        ")\n",
        "res_comb = res_comb.query(\"type !='unknown'\")\n",
        "\n",
        "res_comb =  res_comb.reset_index(drop=True)\n",
        "\n",
        "\n",
        "res_test1 = res_test1.sort_values(by=['id']).reset_index().query(\"index !='average_map'\")\n",
        "data_range1 = np.array(list(res_test1['mean']) + list(res_valid1['mean']))\n",
        "categories = [str(i) for i in range(1,26)]\n",
        "fig = go.Figure()\n",
        "\n",
        "# Valid\n",
        "fig.add_trace(go.Scatterpolar(\n",
        "       r=list(res_test1['mean']),\n",
        "      theta=categories,\n",
        "      #fill='toself',\n",
        "      name='Test'\n",
        "))\n",
        "\n",
        "# Test\n",
        "fig.add_trace(go.Scatterpolar(\n",
        "      r=list(res_valid1['mean']),\n",
        "      theta=categories,\n",
        "      #fill='toself',\n",
        "      name='Valid'\n",
        "))\n",
        "\n",
        "# Customization of chart\n",
        "fig.update_layout(\n",
        "  title={\n",
        "      'text': \"T-Test\",\n",
        "        'xanchor': 'center',\n",
        "      'yanchor': 'top'\n",
        "  },\n",
        "  polar=dict(\n",
        "    radialaxis=dict(\n",
        "      visible=True,\n",
        "      range=[round(data_range1.min()), round(data_range1.max()) + 1]\n",
        "    )),\n",
        "  showlegend=True\n",
        ")\n",
        "\n",
        "fig.show()\n",
        "\n",
        "##############\n",
        "\n",
        "\n",
        "res_valid2['id'] = res_valid2.index.to_series().apply(extract_number)\n",
        "res_test2['id'] = res_test2.index.to_series().apply(extract_number)\n",
        "\n",
        "\n",
        "\n",
        "res_comb = pd.concat([res_valid2,res_test2])\n",
        "index_series = res_comb.index.to_series()\n",
        "\n",
        "res_comb['type'] = np.where(\n",
        "    index_series.str.contains('valid', case=False), 'valid',\n",
        "    np.where(index_series.str.contains('test', case=False), 'test', 'unknown')\n",
        ")\n",
        "res_comb = res_comb.query(\"type !='unknown'\")\n",
        "\n",
        "res_comb =  res_comb.reset_index(drop=True)\n",
        "\n",
        "\n",
        "res_test2 = res_test2.sort_values(by=['id']).reset_index().query(\"index !='average_map'\")\n",
        "\n",
        "data_range2 = np.array(list(res_test2['mean']) + list(res_valid2['mean']))\n",
        "\n",
        "categories = [str(i) for i in range(1,26)]\n",
        "fig = go.Figure()\n",
        "\n",
        "# Valid\n",
        "fig.add_trace(go.Scatterpolar(\n",
        "       r=list(res_test2['mean']),\n",
        "      theta=categories,\n",
        "      #fill='toself',\n",
        "      name='Test'\n",
        "))\n",
        "\n",
        "# Test\n",
        "fig.add_trace(go.Scatterpolar(\n",
        "      r=list(res_valid2['mean']),\n",
        "      theta=categories,\n",
        "      #fill='toself',\n",
        "      name='Valid'\n",
        "))\n",
        "\n",
        "# Customization of chart\n",
        "fig.update_layout(\n",
        "  title={\n",
        "      'text': \"MU-Test\",\n",
        "         'xanchor': 'center',\n",
        "      'yanchor': 'top'\n",
        "  },\n",
        "  polar=dict(\n",
        "    radialaxis=dict(\n",
        "      visible=True,\n",
        "      range=[round(data_range2.min()), round(data_range2.max()) + 1]\n",
        "    )),\n",
        "  showlegend=True\n",
        ")\n",
        "\n",
        "fig.show()\n",
        "fig.write_image(\"images/fig1.png\")"
      ],
      "id": "293fa4b6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "</br>\n",
        "\n",
        "</br>\n",
        "\n",
        "</br>\n",
        "\n",
        "\n",
        ":::\n",
        "\n",
        "\n",
        "##  Bit size 48\n",
        "\n",
        "\n",
        "The results in this presentation are from two experimental designs:\n",
        "\n",
        "::: {.panel-tabset}\n",
        "\n",
        "###  Experiment 1 Results\n",
        "\n",
        "The thresholding is based on fixed values between -1 and 1 on a step size of 0.1.\n",
        "\n",
        "\n",
        "\n",
        "::: {.panel-tabset}\n"
      ],
      "id": "f06d394e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#%%\n",
        "\n",
        "dt_valid  = pd.read_csv(f\"descriptors_tain_valid_test/v3_layers_v2/merged_validation_runs_wide_format_abs_13062024_{layer_vsn}.csv\")\n",
        "\n",
        "\n",
        "dt_test  = pd.read_csv(f\"descriptors_tain_valid_test/v3_layers_v2/merged_test_runs_wide_format_abs_13062024_{layer_vsn}.csv\")\n",
        "\n",
        "\n",
        "\n",
        "output_size = 48\n",
        "\n",
        "\n",
        "dt_valid = dt_valid.query(query)\n",
        "\n",
        "dt_test = dt_test.query(query)"
      ],
      "id": "dfc2898a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### Validation Data mAP Results Preview:\n"
      ],
      "id": "8a25cbc2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "#| \n",
        "html_table = dt_valid.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))"
      ],
      "id": "a2bb44f3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "</br>\n",
        "\n",
        "#### Test Data mAP Results Preview:\n"
      ],
      "id": "b7eafba0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "#| \n",
        "html_table = dt_test.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))"
      ],
      "id": "a5c0f30c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {.panel-tabset}\n",
        "\n",
        "</br>\n",
        "\n",
        "The global mean maximum row:\n"
      ],
      "id": "bd9548b2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "################\n",
        "dt_valid_sub = dt_valid[list(dt_valid.columns[dt_valid.columns.str.startswith('mAP_valid')])]\n",
        "\n",
        "# Apply the function row-wise\n",
        "dt_valid_sub['average_map'] = dt_valid_sub.apply(np.mean, axis=1)\n",
        "dt_valid_sub.sort_values(by='average_map', ascending=False, inplace=True)\n",
        "\n",
        "#maximum mean value\n",
        "dt_valid_sub['average_map'].max()\n",
        "\n",
        "\n",
        "\n",
        "#########\n",
        "\n",
        "\n",
        "# extract max value row.\n",
        "\n",
        "max_index = dt_valid_sub['average_map'].idxmax()\n",
        "max_row = dt_valid_sub.loc[max_index]\n",
        "#print(max_row)\n",
        "dt_valid_sub_mw = dt_valid_sub.copy()"
      ],
      "id": "afd69804",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "dd = dt_valid_sub.head(1)\n",
        "\n",
        "html_table = dd.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 100px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))"
      ],
      "id": "13bb4cff",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### Model performance on validation data (T-test)\n",
        "\n",
        "\n",
        "\n",
        "##### Statistical Significance:\n",
        "\n",
        "\n",
        "Using the global mean maximum row as the reference, we perform the right-tailed t-test to identify significant hyperparameters.\n"
      ],
      "id": "7a7ce1ec"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pvalues = []\n",
        "pvalues_real = []\n",
        "\n",
        "for _,index in enumerate(dt_valid_sub.index):\n",
        "  _, p_value = stats.ttest_ind(max_row[:-1], dt_valid_sub.loc[index][:-1], alternative='greater')\n",
        "  pvalues_real.append(p_value)\n",
        "  pvalues.append((p_value >= 0.05)*1)\n",
        "\n",
        "  \n",
        "\n",
        "dt_valid_sub['pvalues'] = pvalues_real\n",
        "dt_valid_sub['sig'] = pvalues\n",
        "\n",
        "\n",
        "dt_valid_sub1 = dt_valid_sub.query('sig == 1')\n",
        "\n",
        "\n",
        "max_indexx = dt_valid_sub1.iloc[:, :-3].mean().idxmax()\n",
        "\n",
        "#print(sum(pvalues),max_indexx)"
      ],
      "id": "ea71abdf",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "dt = dt_valid.loc[dt_valid_sub1.index].sort_values(by = ['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "html_table = dt.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "\n",
        "print('Size of the All data: ',dt_valid_sub.shape)\n",
        "\n",
        "print('Size of the Sig data: ',dt_valid_sub1.shape)"
      ],
      "id": "eb8f8823",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "####################################################\n",
        "# Use the hyperparameters to the test data.\n",
        "####################################################\n",
        "optimal_params1 = dt_valid.loc[dt_valid_sub1.index][['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg']]\n",
        "optimal_params = optimal_params1.reset_index()\n",
        "optimal_params.drop(['index'], axis=1, inplace = True)\n",
        "\n",
        "#rotation invariance test data with optimal parameters\n",
        "test_data_1 = pd.merge(optimal_params, dt_test, on=['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "test_data_1_sub = test_data_1[list(test_data_1.columns[test_data_1.columns.str.startswith('mAP_test')])]"
      ],
      "id": "5c9c9751",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Equivalent test data\n"
      ],
      "id": "97682acc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "test_data_1 = test_data_1.sort_values(by = ['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "html_table = test_data_1.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "print('Size of the test data: ',test_data_1.shape)"
      ],
      "id": "a1ce0263",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Difference\n"
      ],
      "id": "81fd3479"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "diff = dt[['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg']]\n",
        "for i, cols in enumerate(zip(dt.columns,test_data_1.columns)):   \n",
        "   diff[f'col_diff_{i}'] = (np.array(dt[cols[0]]) - np.array(test_data_1[cols[1]]))*-1\n",
        "\n",
        "# Function to count negatives in a row\n",
        "def count_negatives(row):\n",
        "    return sum(1 for value in row if isinstance(value, (int, float)) and value < 0)\n",
        "\n",
        "diff['negative_count'] = diff.apply(count_negatives, axis=1)\n",
        "diff.sort_values(by =[\"negative_count\"],inplace = True, ascending=False)\n",
        "\n",
        "html_table = diff.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "\n",
        "# \n",
        "# show(diff)"
      ],
      "id": "be54a953",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.panel-tabset}\n",
        "\n",
        "##### Model performance on valid data\n",
        "\n",
        "Average & Std Deviation of the Significant rows:\n"
      ],
      "id": "10f4264d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "res = dt_valid_sub1.iloc[:,:-3].describe().iloc[1:3]\n",
        "\n",
        "res_valid1 = res.T.sort_values(by=['mean'], ascending= False)\n",
        "\n",
        "html_table = res_valid1.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n"
      ],
      "id": "d68dd795",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##### Model performance on Test data\n",
        "</br>\n",
        "We then apply the hyperparameters to the test set and average the results.\n"
      ],
      "id": "a7581d1e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "test_data_1['average_map'] = test_data_1_sub.apply(np.mean, axis=1)\n",
        "\n",
        "test_data_1.sort_values(by=['average_map'], ascending= False,inplace=True)"
      ],
      "id": "fae70dcc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "res = test_data_1.describe().iloc[1:3][list(test_data_1.columns[test_data_1.columns.str.startswith('mAP_test')])+ ['average_map']]\n",
        "\n",
        "res_test1 = res.T.sort_values(by=['mean'], ascending= False)\n",
        "\n",
        "html_table = res_test1.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n"
      ],
      "id": "768bf77b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "#### Model performance on validation data (Mann-Whitney U Test)\n",
        "\n",
        "##### Statistical Significance:\n",
        "\n",
        "\n",
        "Using the global mean maximum row as the reference, we perform the right-tailed t-test to identify significant hyperparameters.\n"
      ],
      "id": "2c3bbd59"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pvalues_mw = []\n",
        "pvalues_real_mw = []\n",
        "\n",
        "for _,index in enumerate(dt_valid_sub.index):\n",
        "\n",
        "  _, p_value_mw = stats.mannwhitneyu(max_row[:-1], dt_valid_sub.loc[index][:-1], alternative='greater')#, method = 'asymptotic')\n",
        "  pvalues_real_mw.append(p_value_mw)\n",
        "  pvalues_mw.append((p_value_mw >= 0.05)*1)\n",
        "  \n",
        "\n",
        "dt_valid_sub_mw['pvalues_mw'] = pvalues_real_mw\n",
        "dt_valid_sub_mw['sig_mw'] = pvalues_mw\n",
        "\n",
        "dt_valid_sub_mw1 = dt_valid_sub_mw.query('sig_mw == 1')\n",
        "\n",
        "\n",
        "max_indexx = dt_valid_sub_mw1.iloc[:, :-3].mean().idxmax()\n",
        "\n",
        "#print(sum(pvalues),max_indexx)"
      ],
      "id": "54b5d541",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "\n",
        "dt_mw = dt_valid.loc[dt_valid_sub_mw1.index].sort_values(by = ['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "html_table = dt_mw.to_html(index=True)\n",
        "\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "\n",
        "print('Size of the All data: ',dt_valid_sub_mw.shape)\n",
        "\n",
        "print('Size of the Sig data: ',dt_mw.shape)"
      ],
      "id": "5d7fa141",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "####################################################\n",
        "# Use the hyperparameters to the test data.\n",
        "####################################################\n",
        "optimal_params_mw1 = dt_valid.loc[dt_valid_sub_mw1.index][['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg']]\n",
        "optimal_params_mw = optimal_params_mw1.reset_index()\n",
        "optimal_params_mw.drop(['index'], axis=1, inplace = True)\n",
        "\n",
        "#rotation invariance test data with optimal parameters\n",
        "test_data_mw1 = pd.merge(optimal_params_mw, dt_test, on=['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "test_data_1_sub_mw = test_data_mw1[list(test_data_mw1.columns[test_data_mw1.columns.str.startswith('mAP_test')])]"
      ],
      "id": "ac33150a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Equivalent test data\n"
      ],
      "id": "789ef1cc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "test_data_mw1 = test_data_mw1.sort_values(by = ['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "html_table = test_data_mw1.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "print('Size of the test data: ',test_data_mw1.shape)"
      ],
      "id": "83e5f2f1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Difference\n"
      ],
      "id": "723872f1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "diff_mw = dt_mw[['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg']]\n",
        "for i, cols in enumerate(zip(dt_mw.columns,test_data_mw1.columns)):   \n",
        "   diff_mw[f'col_diff_{i}'] = (np.array(dt_mw[cols[0]]) - np.array(test_data_mw1[cols[1]]))*-1\n",
        "\n",
        "# Function to count negatives in a row\n",
        "def count_negatives(row):\n",
        "    return sum(1 for value in row if isinstance(value, (int, float)) and value < 0)\n",
        "\n",
        "diff_mw['negative_count'] = diff_mw.apply(count_negatives, axis=1)\n",
        "\n",
        "diff_mw.sort_values(by =[\"negative_count\"],inplace = True, ascending=False)\n",
        "\n",
        "\n",
        "html_table = diff_mw.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "\n",
        "key_values = ['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg']\n",
        "print('Are the keys of the valid and test dfs same?: ',dt_mw[key_values].equals(test_data_mw1[key_values]))"
      ],
      "id": "85818e43",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "\n",
        "# Function to count negatives in a row\n",
        "def count_negatives(row):\n",
        "    return sum(1 for value in row if isinstance(value, (int, float)) and value < 0)\n",
        "\n",
        "diff_mw['negative_count'] = diff_mw.apply(count_negatives, axis=1)\n",
        "# show(diff)"
      ],
      "id": "d6fc3940",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.panel-tabset}\n",
        "\n",
        "##### Model performance on valid data \n",
        "\n",
        "Average & Std Deviation of the Significant rows:\n"
      ],
      "id": "1c95b669"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "res = dt_valid_sub_mw1.iloc[:,:-3].describe().iloc[1:3]\n",
        "\n",
        "res_valid2 = res.T.sort_values(by=['mean'], ascending= False)\n",
        "\n",
        "html_table = res_valid2.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n"
      ],
      "id": "692b3c55",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##### Model performance on Test data \n",
        "</br>\n",
        "We then apply the hyperparameters to the test set and average the results.\n"
      ],
      "id": "b84d3894"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "####################################################\n",
        "# Use the hyperparameters to the test data.\n",
        "####################################################\n",
        "optimal_params = dt_valid.loc[dt_valid_sub_mw1.index].iloc[:, :6].reset_index()\n",
        "optimal_params.drop(['index'], axis=1, inplace = True)\n",
        "\n",
        "#rotation invariance test data with optimal parameters\n",
        "test_data_1 = pd.merge(optimal_params, dt_test, how='left')\n",
        "test_data_1_sub = test_data_1[list(test_data_1.columns[test_data_1.columns.str.startswith('mAP_test')])]\n",
        "test_data_1['average_map'] = test_data_1_sub.apply(np.mean, axis=1)\n",
        "\n",
        "test_data_1.sort_values(by=['average_map'], ascending= False,inplace=True)"
      ],
      "id": "f5afd33c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "res = test_data_1.describe().iloc[1:3][list(test_data_1.columns[test_data_1.columns.str.startswith('mAP_test')]) + ['average_map']]\n",
        "\n",
        "res_test2 = res.T.sort_values(by=['mean'], ascending= False)\n",
        "\n",
        "html_table = res_test2.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))"
      ],
      "id": "92a9989d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        ":::\n",
        "\n",
        "</br>\n",
        "\n",
        "\n",
        "Summary using radar plot\n"
      ],
      "id": "3caf1824"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| layout-ncol: 2\n",
        "#| \n",
        "def extract_number(text):\n",
        "    if isinstance(text, str):\n",
        "        matches = re.findall(r'\\d+', text)\n",
        "        return int(matches[0]) if matches else 1\n",
        "    return 1\n",
        "\n",
        "res_valid1['id'] = res_valid1.index.to_series().apply(extract_number)\n",
        "res_test1['id'] = res_test1.index.to_series().apply(extract_number)\n",
        "\n",
        "\n",
        "\n",
        "res_comb = pd.concat([res_valid1,res_test1])\n",
        "index_series = res_comb.index.to_series()\n",
        "\n",
        "res_comb['type'] = np.where(\n",
        "    index_series.str.contains('valid', case=False), 'valid',\n",
        "    np.where(index_series.str.contains('test', case=False), 'test', 'unknown')\n",
        ")\n",
        "res_comb = res_comb.query(\"type !='unknown'\")\n",
        "\n",
        "res_comb =  res_comb.reset_index(drop=True)\n",
        "\n",
        "\n",
        "res_test1 = res_test1.sort_values(by=['id']).reset_index().query(\"index !='average_map'\")\n",
        "data_range1 = np.array(list(res_test1['mean']) + list(res_valid1['mean']))\n",
        "categories = [str(i) for i in range(1,26)]\n",
        "fig = go.Figure()\n",
        "\n",
        "# Valid\n",
        "fig.add_trace(go.Scatterpolar(\n",
        "       r=list(res_test1['mean']),\n",
        "      theta=categories,\n",
        "      #fill='toself',\n",
        "      name='Test'\n",
        "))\n",
        "\n",
        "# Test\n",
        "fig.add_trace(go.Scatterpolar(\n",
        "      r=list(res_valid1['mean']),\n",
        "      theta=categories,\n",
        "      #fill='toself',\n",
        "      name='Valid'\n",
        "))\n",
        "\n",
        "# Customization of chart\n",
        "fig.update_layout(\n",
        "  title={\n",
        "      'text': \"T-Test\",\n",
        "        'xanchor': 'center',\n",
        "      'yanchor': 'top'\n",
        "  },\n",
        "  polar=dict(\n",
        "    radialaxis=dict(\n",
        "      visible=True,\n",
        "      range=[round(data_range1.min()), round(data_range1.max()) + 1]\n",
        "    )),\n",
        "  showlegend=True\n",
        ")\n",
        "\n",
        "fig.show()\n",
        "\n",
        "##############\n",
        "\n",
        "\n",
        "res_valid2['id'] = res_valid2.index.to_series().apply(extract_number)\n",
        "res_test2['id'] = res_test2.index.to_series().apply(extract_number)\n",
        "\n",
        "\n",
        "\n",
        "res_comb = pd.concat([res_valid2,res_test2])\n",
        "index_series = res_comb.index.to_series()\n",
        "\n",
        "res_comb['type'] = np.where(\n",
        "    index_series.str.contains('valid', case=False), 'valid',\n",
        "    np.where(index_series.str.contains('test', case=False), 'test', 'unknown')\n",
        ")\n",
        "res_comb = res_comb.query(\"type !='unknown'\")\n",
        "\n",
        "res_comb =  res_comb.reset_index(drop=True)\n",
        "\n",
        "\n",
        "res_test2 = res_test2.sort_values(by=['id']).reset_index().query(\"index !='average_map'\")\n",
        "\n",
        "data_range2 = np.array(list(res_test2['mean']) + list(res_valid2['mean']))\n",
        "\n",
        "categories = [str(i) for i in range(1,26)]\n",
        "fig = go.Figure()\n",
        "\n",
        "# Valid\n",
        "fig.add_trace(go.Scatterpolar(\n",
        "       r=list(res_test2['mean']),\n",
        "      theta=categories,\n",
        "      #fill='toself',\n",
        "      name='Test'\n",
        "))\n",
        "\n",
        "# Test\n",
        "fig.add_trace(go.Scatterpolar(\n",
        "      r=list(res_valid2['mean']),\n",
        "      theta=categories,\n",
        "      #fill='toself',\n",
        "      name='Valid'\n",
        "))\n",
        "\n",
        "# Customization of chart\n",
        "fig.update_layout(\n",
        "  title={\n",
        "      'text': \"MU-Test\",\n",
        "         'xanchor': 'center',\n",
        "      'yanchor': 'top'\n",
        "  },\n",
        "  polar=dict(\n",
        "    radialaxis=dict(\n",
        "      visible=True,\n",
        "      range=[round(data_range2.min()), round(data_range2.max()) + 1]\n",
        "    )),\n",
        "  showlegend=True\n",
        ")\n",
        "\n",
        "fig.show()"
      ],
      "id": "61328ce9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "</br>\n",
        "\n",
        "</br>\n",
        "\n",
        "</br>\n",
        "\n",
        "\n",
        ":::\n",
        "\n",
        "##  Bit size 16 \n",
        "\n",
        "\n",
        "The results in this presentation are from two experimental designs:\n",
        "\n",
        "::: {.panel-tabset}\n",
        "\n",
        "###  Experiment 1 Results\n",
        "\n",
        "The thresholding is based on fixed values between -1 and 1 on a step size of 0.1.\n",
        "\n",
        "\n",
        "\n",
        "::: {.panel-tabset}\n"
      ],
      "id": "3d0e9191"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#%%\n",
        "\n",
        "dt_valid  = pd.read_csv(f\"descriptors_tain_valid_test/v3_layers_v2/merged_validation_runs_wide_format_abs_13062024_{layer_vsn}.csv\")\n",
        "\n",
        "\n",
        "dt_test  = pd.read_csv(f\"descriptors_tain_valid_test/v3_layers_v2/merged_test_runs_wide_format_abs_13062024_{layer_vsn}.csv\")\n",
        "\n",
        "\n",
        "\n",
        "output_size = 16\n",
        "\n",
        "dt_valid = dt_valid.query(query)\n",
        "\n",
        "dt_test = dt_test.query(query)"
      ],
      "id": "ce3b3847",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### Validation Data mAP Results Preview:\n"
      ],
      "id": "bb5106bb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "#| \n",
        "html_table = dt_valid.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))"
      ],
      "id": "d7753366",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "</br>\n",
        "\n",
        "#### Test Data mAP Results Preview:\n"
      ],
      "id": "464e2011"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "#| \n",
        "html_table = dt_test.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))"
      ],
      "id": "892b2efa",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {.panel-tabset}\n",
        "\n",
        "</br>\n",
        "\n",
        "The global mean maximum row:\n"
      ],
      "id": "19a6bc03"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "################\n",
        "dt_valid_sub = dt_valid[list(dt_valid.columns[dt_valid.columns.str.startswith('mAP_valid')])]\n",
        "\n",
        "# Apply the function row-wise\n",
        "dt_valid_sub['average_map'] = dt_valid_sub.apply(np.mean, axis=1)\n",
        "dt_valid_sub.sort_values(by='average_map', ascending=False, inplace=True)\n",
        "\n",
        "#maximum mean value\n",
        "dt_valid_sub['average_map'].max()\n",
        "\n",
        "\n",
        "\n",
        "#########\n",
        "\n",
        "\n",
        "# extract max value row.\n",
        "\n",
        "max_index = dt_valid_sub['average_map'].idxmax()\n",
        "max_row = dt_valid_sub.loc[max_index]\n",
        "#print(max_row)\n",
        "dt_valid_sub_mw = dt_valid_sub.copy()"
      ],
      "id": "e370eba9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "dd = dt_valid_sub.head(1)\n",
        "\n",
        "html_table = dd.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 100px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))"
      ],
      "id": "097ee7ca",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### Model performance on validation data (T-test)\n",
        "\n",
        "\n",
        "\n",
        "##### Statistical Significance:\n",
        "\n",
        "\n",
        "Using the global mean maximum row as the reference, we perform the right-tailed t-test to identify significant hyperparameters.\n"
      ],
      "id": "2f9c1dfb"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pvalues = []\n",
        "pvalues_real = []\n",
        "\n",
        "for _,index in enumerate(dt_valid_sub.index):\n",
        "  _, p_value = stats.ttest_ind(max_row[:-1], dt_valid_sub.loc[index][:-1], alternative='greater')\n",
        "  pvalues_real.append(p_value)\n",
        "  pvalues.append((p_value >= 0.05)*1)\n",
        "\n",
        "  \n",
        "\n",
        "dt_valid_sub['pvalues'] = pvalues_real\n",
        "dt_valid_sub['sig'] = pvalues\n",
        "\n",
        "\n",
        "dt_valid_sub1 = dt_valid_sub.query('sig == 1')\n",
        "\n",
        "\n",
        "max_indexx = dt_valid_sub1.iloc[:, :-3].mean().idxmax()\n",
        "\n",
        "#print(sum(pvalues),max_indexx)"
      ],
      "id": "c3e1dfa8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "dt = dt_valid.loc[dt_valid_sub1.index].sort_values(by = ['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "html_table = dt.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "\n",
        "print('Size of the All data: ',dt_valid_sub.shape)\n",
        "\n",
        "print('Size of the Sig data: ',dt_valid_sub1.shape)"
      ],
      "id": "cc1dcfec",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "####################################################\n",
        "# Use the hyperparameters to the test data.\n",
        "####################################################\n",
        "optimal_params1 = dt_valid.loc[dt_valid_sub1.index][['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg']]\n",
        "optimal_params = optimal_params1.reset_index()\n",
        "optimal_params.drop(['index'], axis=1, inplace = True)\n",
        "\n",
        "#rotation invariance test data with optimal parameters\n",
        "test_data_1 = pd.merge(optimal_params, dt_test, on=['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "test_data_1_sub = test_data_1[list(test_data_1.columns[test_data_1.columns.str.startswith('mAP_test')])]"
      ],
      "id": "557c14de",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Equivalent test data\n"
      ],
      "id": "56952cda"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "test_data_1 = test_data_1.sort_values(by = ['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "html_table = test_data_1.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "print('Size of the test data: ',test_data_1.shape)"
      ],
      "id": "1aea91db",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Difference\n"
      ],
      "id": "96ef7d26"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "diff = dt[['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg']]\n",
        "for i, cols in enumerate(zip(dt.columns,test_data_1.columns)):   \n",
        "   diff[f'col_diff_{i}'] = (np.array(dt[cols[0]]) - np.array(test_data_1[cols[1]]))*-1\n",
        "\n",
        "# Function to count negatives in a row\n",
        "def count_negatives(row):\n",
        "    return sum(1 for value in row if isinstance(value, (int, float)) and value < 0)\n",
        "\n",
        "diff['negative_count'] = diff.apply(count_negatives, axis=1)\n",
        "diff.sort_values(by =[\"negative_count\"],inplace = True, ascending=False)\n",
        "\n",
        "html_table = diff.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "\n",
        "# \n",
        "# show(diff)"
      ],
      "id": "5af65d93",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.panel-tabset}\n",
        "\n",
        "##### Model performance on valid data\n",
        "\n",
        "Average & Std Deviation of the Significant rows:\n"
      ],
      "id": "12777eef"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "res = dt_valid_sub1.iloc[:,:-3].describe().iloc[1:3]\n",
        "\n",
        "res_valid1 = res.T.sort_values(by=['mean'], ascending= False)\n",
        "\n",
        "html_table = res_valid1.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n"
      ],
      "id": "a21a2012",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##### Model performance on Test data\n",
        "</br>\n",
        "We then apply the hyperparameters to the test set and average the results.\n"
      ],
      "id": "04d1689a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "test_data_1['average_map'] = test_data_1_sub.apply(np.mean, axis=1)\n",
        "\n",
        "test_data_1.sort_values(by=['average_map'], ascending= False,inplace=True)"
      ],
      "id": "d25eacfe",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "res = test_data_1.describe().iloc[1:3][list(test_data_1.columns[test_data_1.columns.str.startswith('mAP_test')])+ ['average_map']]\n",
        "\n",
        "res_test1 = res.T.sort_values(by=['mean'], ascending= False)\n",
        "\n",
        "html_table = res_test1.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n"
      ],
      "id": "5ead252d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "#### Model performance on validation data (Mann-Whitney U Test)\n",
        "\n",
        "##### Statistical Significance:\n",
        "\n",
        "\n",
        "Using the global mean maximum row as the reference, we perform the right-tailed t-test to identify significant hyperparameters.\n"
      ],
      "id": "2b98dc48"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pvalues_mw = []\n",
        "pvalues_real_mw = []\n",
        "\n",
        "for _,index in enumerate(dt_valid_sub.index):\n",
        "\n",
        "  _, p_value_mw = stats.mannwhitneyu(max_row[:-1], dt_valid_sub.loc[index][:-1], alternative='greater')#, method = 'asymptotic')\n",
        "  pvalues_real_mw.append(p_value_mw)\n",
        "  pvalues_mw.append((p_value_mw >= 0.05)*1)\n",
        "  \n",
        "\n",
        "dt_valid_sub_mw['pvalues_mw'] = pvalues_real_mw\n",
        "dt_valid_sub_mw['sig_mw'] = pvalues_mw\n",
        "\n",
        "dt_valid_sub_mw1 = dt_valid_sub_mw.query('sig_mw == 1')\n",
        "\n",
        "\n",
        "max_indexx = dt_valid_sub_mw1.iloc[:, :-3].mean().idxmax()\n",
        "\n",
        "#print(sum(pvalues),max_indexx)"
      ],
      "id": "3f32420a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "\n",
        "dt_mw = dt_valid.loc[dt_valid_sub_mw1.index].sort_values(by = ['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "html_table = dt_mw.to_html(index=True)\n",
        "\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "\n",
        "print('Size of the All data: ',dt_valid_sub_mw.shape)\n",
        "\n",
        "print('Size of the Sig data: ',dt_mw.shape)"
      ],
      "id": "bf8d0b9e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "####################################################\n",
        "# Use the hyperparameters to the test data.\n",
        "####################################################\n",
        "optimal_params_mw1 = dt_valid.loc[dt_valid_sub_mw1.index][['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg']]\n",
        "optimal_params_mw = optimal_params_mw1.reset_index()\n",
        "optimal_params_mw.drop(['index'], axis=1, inplace = True)\n",
        "\n",
        "#rotation invariance test data with optimal parameters\n",
        "test_data_mw1 = pd.merge(optimal_params_mw, dt_test, on=['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "test_data_1_sub_mw = test_data_mw1[list(test_data_mw1.columns[test_data_mw1.columns.str.startswith('mAP_test')])]"
      ],
      "id": "4ec4b328",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Equivalent test data\n"
      ],
      "id": "395a19d6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "test_data_mw1 = test_data_mw1.sort_values(by = ['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "html_table = test_data_mw1.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "print('Size of the test data: ',test_data_mw1.shape)"
      ],
      "id": "66ea5ce2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Difference\n"
      ],
      "id": "003bd051"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "diff_mw = dt_mw[['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg']]\n",
        "for i, cols in enumerate(zip(dt_mw.columns,test_data_mw1.columns)):   \n",
        "   diff_mw[f'col_diff_{i}'] = (np.array(dt_mw[cols[0]]) - np.array(test_data_mw1[cols[1]]))*-1\n",
        "\n",
        "# Function to count negatives in a row\n",
        "def count_negatives(row):\n",
        "    return sum(1 for value in row if isinstance(value, (int, float)) and value < 0)\n",
        "\n",
        "diff_mw['negative_count'] = diff_mw.apply(count_negatives, axis=1)\n",
        "\n",
        "diff_mw.sort_values(by =[\"negative_count\"],inplace = True, ascending=False)\n",
        "\n",
        "\n",
        "html_table = diff_mw.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "\n",
        "key_values = ['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg']\n",
        "print('Are the keys of the valid and test dfs same?: ',dt_mw[key_values].equals(test_data_mw1[key_values]))"
      ],
      "id": "53f4feb2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "\n",
        "# Function to count negatives in a row\n",
        "def count_negatives(row):\n",
        "    return sum(1 for value in row if isinstance(value, (int, float)) and value < 0)\n",
        "\n",
        "diff_mw['negative_count'] = diff_mw.apply(count_negatives, axis=1)\n",
        "# show(diff)"
      ],
      "id": "adeea89c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.panel-tabset}\n",
        "\n",
        "##### Model performance on valid data \n",
        "\n",
        "Average & Std Deviation of the Significant rows:\n"
      ],
      "id": "bbbc3418"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "res = dt_valid_sub_mw1.iloc[:,:-3].describe().iloc[1:3]\n",
        "\n",
        "res_valid2 = res.T.sort_values(by=['mean'], ascending= False)\n",
        "\n",
        "html_table = res_valid2.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n"
      ],
      "id": "3ba067f1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##### Model performance on Test data \n",
        "</br>\n",
        "We then apply the hyperparameters to the test set and average the results.\n"
      ],
      "id": "cd048588"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "####################################################\n",
        "# Use the hyperparameters to the test data.\n",
        "####################################################\n",
        "optimal_params = dt_valid.loc[dt_valid_sub_mw1.index].iloc[:, :6].reset_index()\n",
        "optimal_params.drop(['index'], axis=1, inplace = True)\n",
        "\n",
        "#rotation invariance test data with optimal parameters\n",
        "test_data_1 = pd.merge(optimal_params, dt_test, how='left')\n",
        "test_data_1_sub = test_data_1[list(test_data_1.columns[test_data_1.columns.str.startswith('mAP_test')])]\n",
        "test_data_1['average_map'] = test_data_1_sub.apply(np.mean, axis=1)\n",
        "\n",
        "test_data_1.sort_values(by=['average_map'], ascending= False,inplace=True)"
      ],
      "id": "f1572d7f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "res = test_data_1.describe().iloc[1:3][list(test_data_1.columns[test_data_1.columns.str.startswith('mAP_test')]) + ['average_map']]\n",
        "\n",
        "res_test2 = res.T.sort_values(by=['mean'], ascending= False)\n",
        "\n",
        "html_table = res_test2.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))"
      ],
      "id": "49bdda56",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        ":::\n",
        "\n",
        "</br>\n",
        "\n",
        "\n",
        "Summary using radar plot\n"
      ],
      "id": "09064833"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| layout-ncol: 2\n",
        "#| \n",
        "def extract_number(text):\n",
        "    if isinstance(text, str):\n",
        "        matches = re.findall(r'\\d+', text)\n",
        "        return int(matches[0]) if matches else 1\n",
        "    return 1\n",
        "\n",
        "res_valid1['id'] = res_valid1.index.to_series().apply(extract_number)\n",
        "res_test1['id'] = res_test1.index.to_series().apply(extract_number)\n",
        "\n",
        "\n",
        "\n",
        "res_comb = pd.concat([res_valid1,res_test1])\n",
        "index_series = res_comb.index.to_series()\n",
        "\n",
        "res_comb['type'] = np.where(\n",
        "    index_series.str.contains('valid', case=False), 'valid',\n",
        "    np.where(index_series.str.contains('test', case=False), 'test', 'unknown')\n",
        ")\n",
        "res_comb = res_comb.query(\"type !='unknown'\")\n",
        "\n",
        "res_comb =  res_comb.reset_index(drop=True)\n",
        "\n",
        "\n",
        "res_test1 = res_test1.sort_values(by=['id']).reset_index().query(\"index !='average_map'\")\n",
        "data_range1 = np.array(list(res_test1['mean']) + list(res_valid1['mean']))\n",
        "categories = [str(i) for i in range(1,26)]\n",
        "fig = go.Figure()\n",
        "\n",
        "# Valid\n",
        "fig.add_trace(go.Scatterpolar(\n",
        "       r=list(res_test1['mean']),\n",
        "      theta=categories,\n",
        "      #fill='toself',\n",
        "      name='Test'\n",
        "))\n",
        "\n",
        "# Test\n",
        "fig.add_trace(go.Scatterpolar(\n",
        "      r=list(res_valid1['mean']),\n",
        "      theta=categories,\n",
        "      #fill='toself',\n",
        "      name='Valid'\n",
        "))\n",
        "\n",
        "# Customization of chart\n",
        "fig.update_layout(\n",
        "  title={\n",
        "      'text': \"T-Test\",\n",
        "        'xanchor': 'center',\n",
        "      'yanchor': 'top'\n",
        "  },\n",
        "  polar=dict(\n",
        "    radialaxis=dict(\n",
        "      visible=True,\n",
        "      range=[round(data_range1.min()), round(data_range1.max()) + 1]\n",
        "    )),\n",
        "  showlegend=True\n",
        ")\n",
        "\n",
        "fig.show()\n",
        "\n",
        "##############\n",
        "\n",
        "\n",
        "res_valid2['id'] = res_valid2.index.to_series().apply(extract_number)\n",
        "res_test2['id'] = res_test2.index.to_series().apply(extract_number)\n",
        "\n",
        "\n",
        "\n",
        "res_comb = pd.concat([res_valid2,res_test2])\n",
        "index_series = res_comb.index.to_series()\n",
        "\n",
        "res_comb['type'] = np.where(\n",
        "    index_series.str.contains('valid', case=False), 'valid',\n",
        "    np.where(index_series.str.contains('test', case=False), 'test', 'unknown')\n",
        ")\n",
        "res_comb = res_comb.query(\"type !='unknown'\")\n",
        "\n",
        "res_comb =  res_comb.reset_index(drop=True)\n",
        "\n",
        "\n",
        "res_test2 = res_test2.sort_values(by=['id']).reset_index().query(\"index !='average_map'\")\n",
        "\n",
        "data_range2 = np.array(list(res_test2['mean']) + list(res_valid2['mean']))\n",
        "\n",
        "categories = [str(i) for i in range(1,26)]\n",
        "fig = go.Figure()\n",
        "\n",
        "# Valid\n",
        "fig.add_trace(go.Scatterpolar(\n",
        "       r=list(res_test2['mean']),\n",
        "      theta=categories,\n",
        "      #fill='toself',\n",
        "      name='Test'\n",
        "))\n",
        "\n",
        "# Test\n",
        "fig.add_trace(go.Scatterpolar(\n",
        "      r=list(res_valid2['mean']),\n",
        "      theta=categories,\n",
        "      #fill='toself',\n",
        "      name='Valid'\n",
        "))\n",
        "\n",
        "# Customization of chart\n",
        "fig.update_layout(\n",
        "  title={\n",
        "      'text': \"MU-Test\",\n",
        "         'xanchor': 'center',\n",
        "      'yanchor': 'top'\n",
        "  },\n",
        "  polar=dict(\n",
        "    radialaxis=dict(\n",
        "      visible=True,\n",
        "      range=[round(data_range2.min()), round(data_range2.max()) + 1]\n",
        "    )),\n",
        "  showlegend=True\n",
        ")\n",
        "\n",
        "fig.show()"
      ],
      "id": "77660bf9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "</br>\n",
        "\n",
        "</br>\n",
        "\n",
        "</br>\n",
        "\n",
        "\n",
        ":::\n",
        "\n",
        "##  Bit size 8 \n",
        "\n",
        "\n",
        "The results in this presentation are from two experimental designs:\n",
        "\n",
        "::: {.panel-tabset}\n",
        "\n",
        "###  Experiment 1 Results\n",
        "\n",
        "The thresholding is based on fixed values between -1 and 1 on a step size of 0.1.\n",
        "\n",
        "\n",
        "\n",
        "::: {.panel-tabset}\n"
      ],
      "id": "cfe42fd9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#%%\n",
        "\n",
        "dt_valid  = pd.read_csv(f\"descriptors_tain_valid_test/v3_layers_v2/merged_validation_runs_wide_format_abs_13062024_{layer_vsn}.csv\")\n",
        "\n",
        "\n",
        "dt_test  = pd.read_csv(f\"descriptors_tain_valid_test/v3_layers_v2/merged_test_runs_wide_format_abs_13062024_{layer_vsn}.csv\")\n",
        "\n",
        "\n",
        "\n",
        "output_size = 8\n",
        "\n",
        "\n",
        "dt_valid = dt_valid.query(query)\n",
        "\n",
        "dt_test = dt_test.query(query)"
      ],
      "id": "1a5126a9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### Validation Data mAP Results Preview:\n"
      ],
      "id": "066f3182"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "#| \n",
        "html_table = dt_valid.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))"
      ],
      "id": "d0f6fb98",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "</br>\n",
        "\n",
        "#### Test Data mAP Results Preview:\n"
      ],
      "id": "6a1b8de4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "#| \n",
        "html_table = dt_test.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))"
      ],
      "id": "d7bc35d6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "::: {.panel-tabset}\n",
        "\n",
        "</br>\n",
        "\n",
        "The global mean maximum row:\n"
      ],
      "id": "38f93015"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "################\n",
        "dt_valid_sub = dt_valid[list(dt_valid.columns[dt_valid.columns.str.startswith('mAP_valid')])]\n",
        "\n",
        "# Apply the function row-wise\n",
        "dt_valid_sub['average_map'] = dt_valid_sub.apply(np.mean, axis=1)\n",
        "dt_valid_sub.sort_values(by='average_map', ascending=False, inplace=True)\n",
        "\n",
        "#maximum mean value\n",
        "dt_valid_sub['average_map'].max()\n",
        "\n",
        "\n",
        "\n",
        "#########\n",
        "\n",
        "\n",
        "# extract max value row.\n",
        "\n",
        "max_index = dt_valid_sub['average_map'].idxmax()\n",
        "max_row = dt_valid_sub.loc[max_index]\n",
        "#print(max_row)\n",
        "dt_valid_sub_mw = dt_valid_sub.copy()"
      ],
      "id": "b5a984c0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "dd = dt_valid_sub.head(1)\n",
        "\n",
        "html_table = dd.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 100px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))"
      ],
      "id": "9bfe8890",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "#### Model performance on validation data (T-test)\n",
        "\n",
        "\n",
        "\n",
        "##### Statistical Significance:\n",
        "\n",
        "\n",
        "Using the global mean maximum row as the reference, we perform the right-tailed t-test to identify significant hyperparameters.\n"
      ],
      "id": "f3fea0a4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pvalues = []\n",
        "pvalues_real = []\n",
        "\n",
        "for _,index in enumerate(dt_valid_sub.index):\n",
        "  _, p_value = stats.ttest_ind(max_row[:-1], dt_valid_sub.loc[index][:-1], alternative='greater')\n",
        "  pvalues_real.append(p_value)\n",
        "  pvalues.append((p_value >= 0.05)*1)\n",
        "\n",
        "  \n",
        "\n",
        "dt_valid_sub['pvalues'] = pvalues_real\n",
        "dt_valid_sub['sig'] = pvalues\n",
        "\n",
        "\n",
        "dt_valid_sub1 = dt_valid_sub.query('sig == 1')\n",
        "\n",
        "\n",
        "max_indexx = dt_valid_sub1.iloc[:, :-3].mean().idxmax()\n",
        "\n",
        "#print(sum(pvalues),max_indexx)"
      ],
      "id": "c614de87",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "dt = dt_valid.loc[dt_valid_sub1.index].sort_values(by = ['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "html_table = dt.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "\n",
        "print('Size of the All data: ',dt_valid_sub.shape)\n",
        "\n",
        "print('Size of the Sig data: ',dt_valid_sub1.shape)"
      ],
      "id": "8a33179d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "####################################################\n",
        "# Use the hyperparameters to the test data.\n",
        "####################################################\n",
        "optimal_params1 = dt_valid.loc[dt_valid_sub1.index][['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg']]\n",
        "optimal_params = optimal_params1.reset_index()\n",
        "optimal_params.drop(['index'], axis=1, inplace = True)\n",
        "\n",
        "#rotation invariance test data with optimal parameters\n",
        "test_data_1 = pd.merge(optimal_params, dt_test, on=['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "test_data_1_sub = test_data_1[list(test_data_1.columns[test_data_1.columns.str.startswith('mAP_test')])]"
      ],
      "id": "4eb78252",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Equivalent test data\n"
      ],
      "id": "4595082b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "test_data_1 = test_data_1.sort_values(by = ['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "html_table = test_data_1.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "print('Size of the test data: ',test_data_1.shape)"
      ],
      "id": "946e89f9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Difference\n"
      ],
      "id": "a54cc81e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "diff = dt[['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg']]\n",
        "for i, cols in enumerate(zip(dt.columns,test_data_1.columns)):   \n",
        "   diff[f'col_diff_{i}'] = (np.array(dt[cols[0]]) - np.array(test_data_1[cols[1]]))*-1\n",
        "\n",
        "# Function to count negatives in a row\n",
        "def count_negatives(row):\n",
        "    return sum(1 for value in row if isinstance(value, (int, float)) and value < 0)\n",
        "\n",
        "diff['negative_count'] = diff.apply(count_negatives, axis=1)\n",
        "diff.sort_values(by =[\"negative_count\"],inplace = True, ascending=False)\n",
        "\n",
        "html_table = diff.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "\n",
        "# \n",
        "# show(diff)"
      ],
      "id": "fd8874c5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.panel-tabset}\n",
        "\n",
        "##### Model performance on valid data\n",
        "\n",
        "Average & Std Deviation of the Significant rows:\n"
      ],
      "id": "e941409c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "res = dt_valid_sub1.iloc[:,:-3].describe().iloc[1:3]\n",
        "\n",
        "res_valid1 = res.T.sort_values(by=['mean'], ascending= False)\n",
        "\n",
        "html_table = res_valid1.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n"
      ],
      "id": "1f1d71a1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##### Model performance on Test data\n",
        "</br>\n",
        "We then apply the hyperparameters to the test set and average the results.\n"
      ],
      "id": "7b523052"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "test_data_1['average_map'] = test_data_1_sub.apply(np.mean, axis=1)\n",
        "\n",
        "test_data_1.sort_values(by=['average_map'], ascending= False,inplace=True)"
      ],
      "id": "967700da",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "res = test_data_1.describe().iloc[1:3][list(test_data_1.columns[test_data_1.columns.str.startswith('mAP_test')])+ ['average_map']]\n",
        "\n",
        "res_test1 = res.T.sort_values(by=['mean'], ascending= False)\n",
        "\n",
        "html_table = res_test1.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n"
      ],
      "id": "21b1a9eb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "\n",
        "#### Model performance on validation data (Mann-Whitney U Test)\n",
        "\n",
        "##### Statistical Significance:\n",
        "\n",
        "\n",
        "Using the global mean maximum row as the reference, we perform the right-tailed t-test to identify significant hyperparameters.\n"
      ],
      "id": "24a5169b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "pvalues_mw = []\n",
        "pvalues_real_mw = []\n",
        "\n",
        "for _,index in enumerate(dt_valid_sub.index):\n",
        "\n",
        "  _, p_value_mw = stats.mannwhitneyu(max_row[:-1], dt_valid_sub.loc[index][:-1], alternative='greater')#, method = 'asymptotic')\n",
        "  pvalues_real_mw.append(p_value_mw)\n",
        "  pvalues_mw.append((p_value_mw >= 0.05)*1)\n",
        "  \n",
        "\n",
        "dt_valid_sub_mw['pvalues_mw'] = pvalues_real_mw\n",
        "dt_valid_sub_mw['sig_mw'] = pvalues_mw\n",
        "\n",
        "dt_valid_sub_mw1 = dt_valid_sub_mw.query('sig_mw == 1')\n",
        "\n",
        "\n",
        "max_indexx = dt_valid_sub_mw1.iloc[:, :-3].mean().idxmax()\n",
        "\n",
        "#print(sum(pvalues),max_indexx)"
      ],
      "id": "eb81b5f5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "\n",
        "dt_mw = dt_valid.loc[dt_valid_sub_mw1.index].sort_values(by = ['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "html_table = dt_mw.to_html(index=True)\n",
        "\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "\n",
        "print('Size of the All data: ',dt_valid_sub_mw.shape)\n",
        "\n",
        "print('Size of the Sig data: ',dt_mw.shape)"
      ],
      "id": "a1c4e27a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "####################################################\n",
        "# Use the hyperparameters to the test data.\n",
        "####################################################\n",
        "optimal_params_mw1 = dt_valid.loc[dt_valid_sub_mw1.index][['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg']]\n",
        "optimal_params_mw = optimal_params_mw1.reset_index()\n",
        "optimal_params_mw.drop(['index'], axis=1, inplace = True)\n",
        "\n",
        "#rotation invariance test data with optimal parameters\n",
        "test_data_mw1 = pd.merge(optimal_params_mw, dt_test, on=['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "test_data_1_sub_mw = test_data_mw1[list(test_data_mw1.columns[test_data_mw1.columns.str.startswith('mAP_test')])]"
      ],
      "id": "cd48064e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Equivalent test data\n"
      ],
      "id": "af484833"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "test_data_mw1 = test_data_mw1.sort_values(by = ['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg'])\n",
        "html_table = test_data_mw1.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "print('Size of the test data: ',test_data_mw1.shape)"
      ],
      "id": "bf416773",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Difference\n"
      ],
      "id": "7ac0d4bc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "diff_mw = dt_mw[['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg']]\n",
        "for i, cols in enumerate(zip(dt_mw.columns,test_data_mw1.columns)):   \n",
        "   diff_mw[f'col_diff_{i}'] = (np.array(dt_mw[cols[0]]) - np.array(test_data_mw1[cols[1]]))*-1\n",
        "\n",
        "# Function to count negatives in a row\n",
        "def count_negatives(row):\n",
        "    return sum(1 for value in row if isinstance(value, (int, float)) and value < 0)\n",
        "\n",
        "diff_mw['negative_count'] = diff_mw.apply(count_negatives, axis=1)\n",
        "\n",
        "diff_mw.sort_values(by =[\"negative_count\"],inplace = True, ascending=False)\n",
        "\n",
        "\n",
        "html_table = diff_mw.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n",
        "\n",
        "key_values = ['input_size', 'output_size', 'learning_rate', 'batch_size', 'alpha', 'margin', 'l1_reg', 'l2_reg']\n",
        "print('Are the keys of the valid and test dfs same?: ',dt_mw[key_values].equals(test_data_mw1[key_values]))"
      ],
      "id": "4153e9e7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "\n",
        "# Function to count negatives in a row\n",
        "def count_negatives(row):\n",
        "    return sum(1 for value in row if isinstance(value, (int, float)) and value < 0)\n",
        "\n",
        "diff_mw['negative_count'] = diff_mw.apply(count_negatives, axis=1)\n",
        "# show(diff)"
      ],
      "id": "0f6d58bb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.panel-tabset}\n",
        "\n",
        "##### Model performance on valid data \n",
        "\n",
        "Average & Std Deviation of the Significant rows:\n"
      ],
      "id": "5a1674b3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "res = dt_valid_sub_mw1.iloc[:,:-3].describe().iloc[1:3]\n",
        "\n",
        "res_valid2 = res.T.sort_values(by=['mean'], ascending= False)\n",
        "\n",
        "html_table = res_valid2.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))\n"
      ],
      "id": "27a6e6ba",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "##### Model performance on Test data \n",
        "</br>\n",
        "We then apply the hyperparameters to the test set and average the results.\n"
      ],
      "id": "41fe631d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "####################################################\n",
        "# Use the hyperparameters to the test data.\n",
        "####################################################\n",
        "optimal_params = dt_valid.loc[dt_valid_sub_mw1.index].iloc[:, :6].reset_index()\n",
        "optimal_params.drop(['index'], axis=1, inplace = True)\n",
        "\n",
        "#rotation invariance test data with optimal parameters\n",
        "test_data_1 = pd.merge(optimal_params, dt_test, how='left')\n",
        "test_data_1_sub = test_data_1[list(test_data_1.columns[test_data_1.columns.str.startswith('mAP_test')])]\n",
        "test_data_1['average_map'] = test_data_1_sub.apply(np.mean, axis=1)\n",
        "\n",
        "test_data_1.sort_values(by=['average_map'], ascending= False,inplace=True)"
      ],
      "id": "6fadd28d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| echo: false\n",
        "#| code-fold: false\n",
        "res = test_data_1.describe().iloc[1:3][list(test_data_1.columns[test_data_1.columns.str.startswith('mAP_test')]) + ['average_map']]\n",
        "\n",
        "res_test2 = res.T.sort_values(by=['mean'], ascending= False)\n",
        "\n",
        "html_table = res_test2.to_html(index=True)\n",
        "\n",
        "# Wrap in a scrollable div\n",
        "scrollable_table = f\"\"\"\n",
        "<div style=\"height: 400px; width: 100%; overflow-x: auto; overflow-y: auto;\">\n",
        "    {html_table}\n",
        "</div>\n",
        "\"\"\"\n",
        "# Display the scrollable table\n",
        "display(HTML(scrollable_table))"
      ],
      "id": "bbf669dd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        ":::\n",
        ":::\n",
        "\n",
        "</br>\n",
        "\n",
        "\n",
        "Summary using radar plot\n"
      ],
      "id": "bd1bd8f1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| layout-ncol: 2\n",
        "#| \n",
        "def extract_number(text):\n",
        "    if isinstance(text, str):\n",
        "        matches = re.findall(r'\\d+', text)\n",
        "        return int(matches[0]) if matches else 1\n",
        "    return 1\n",
        "\n",
        "res_valid1['id'] = res_valid1.index.to_series().apply(extract_number)\n",
        "res_test1['id'] = res_test1.index.to_series().apply(extract_number)\n",
        "\n",
        "\n",
        "\n",
        "res_comb = pd.concat([res_valid1,res_test1])\n",
        "index_series = res_comb.index.to_series()\n",
        "\n",
        "res_comb['type'] = np.where(\n",
        "    index_series.str.contains('valid', case=False), 'valid',\n",
        "    np.where(index_series.str.contains('test', case=False), 'test', 'unknown')\n",
        ")\n",
        "res_comb = res_comb.query(\"type !='unknown'\")\n",
        "\n",
        "res_comb =  res_comb.reset_index(drop=True)\n",
        "\n",
        "\n",
        "res_test1 = res_test1.sort_values(by=['id']).reset_index().query(\"index !='average_map'\")\n",
        "data_range1 = np.array(list(res_test1['mean']) + list(res_valid1['mean']))\n",
        "categories = [str(i) for i in range(1,26)]\n",
        "fig = go.Figure()\n",
        "\n",
        "# Valid\n",
        "fig.add_trace(go.Scatterpolar(\n",
        "       r=list(res_test1['mean']),\n",
        "      theta=categories,\n",
        "      #fill='toself',\n",
        "      name='Test'\n",
        "))\n",
        "\n",
        "# Test\n",
        "fig.add_trace(go.Scatterpolar(\n",
        "      r=list(res_valid1['mean']),\n",
        "      theta=categories,\n",
        "      #fill='toself',\n",
        "      name='Valid'\n",
        "))\n",
        "\n",
        "# Customization of chart\n",
        "fig.update_layout(\n",
        "  title={\n",
        "      'text': \"T-Test\",\n",
        "        'xanchor': 'center',\n",
        "      'yanchor': 'top'\n",
        "  },\n",
        "  polar=dict(\n",
        "    radialaxis=dict(\n",
        "      visible=True,\n",
        "      range=[round(data_range1.min()), round(data_range1.max()) + 1 + 1]\n",
        "    )),\n",
        "  showlegend=True\n",
        ")\n",
        "\n",
        "fig.show()\n",
        "\n",
        "##############\n",
        "\n",
        "\n",
        "res_valid2['id'] = res_valid2.index.to_series().apply(extract_number)\n",
        "res_test2['id'] = res_test2.index.to_series().apply(extract_number)\n",
        "\n",
        "\n",
        "\n",
        "res_comb = pd.concat([res_valid2,res_test2])\n",
        "index_series = res_comb.index.to_series()\n",
        "\n",
        "res_comb['type'] = np.where(\n",
        "    index_series.str.contains('valid', case=False), 'valid',\n",
        "    np.where(index_series.str.contains('test', case=False), 'test', 'unknown')\n",
        ")\n",
        "res_comb = res_comb.query(\"type !='unknown'\")\n",
        "\n",
        "res_comb =  res_comb.reset_index(drop=True)\n",
        "\n",
        "\n",
        "res_test2 = res_test2.sort_values(by=['id']).reset_index().query(\"index !='average_map'\")\n",
        "\n",
        "data_range2 = np.array(list(res_test2['mean']) + list(res_valid2['mean']))\n",
        "\n",
        "categories = [str(i) for i in range(1,26)]\n",
        "fig = go.Figure()\n",
        "\n",
        "# Valid\n",
        "fig.add_trace(go.Scatterpolar(\n",
        "       r=list(res_test2['mean']),\n",
        "      theta=categories,\n",
        "      #fill='toself',\n",
        "      name='Test'\n",
        "))\n",
        "\n",
        "# Test\n",
        "fig.add_trace(go.Scatterpolar(\n",
        "      r=list(res_valid2['mean']),\n",
        "      theta=categories,\n",
        "      #fill='toself',\n",
        "      name='Valid'\n",
        "))\n",
        "\n",
        "# Customization of chart\n",
        "fig.update_layout(\n",
        "  title={\n",
        "      'text': \"MU-Test\",\n",
        "         'xanchor': 'center',\n",
        "      'yanchor': 'top'\n",
        "  },\n",
        "  polar=dict(\n",
        "    radialaxis=dict(\n",
        "      visible=True,\n",
        "      range=[round(data_range2.min()), round(data_range2.max()) + 1]\n",
        "    )),\n",
        "  showlegend=True\n",
        ")\n",
        "\n",
        "fig.show()"
      ],
      "id": "caa36dd3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "</br>\n",
        "\n",
        "</br>\n",
        "\n",
        "</br>\n",
        "\n",
        "\n",
        ":::\n",
        "\n",
        "\n",
        ":::\n",
        "\n",
        "\n",
        "\n",
        ":::\n",
        "\n",
        "Comparisons of bit size results\n"
      ],
      "id": "8eeed20e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| layout-ncol: 2\n",
        "#| column: screen\n",
        "#| echo: false\n",
        "#| code-fold: false\n",
        "\n",
        "# data = {'bit_size':[8,16,32,48],\n",
        "#         'Valid': [best_valid_bit_size_8,best_valid_bit_size_16,best_valid_bit_size_32,best_valid_bit_size_48],\n",
        "#         'Test': [best_test_bit_size_8, best_test_bit_size_16, best_test_bit_size_32,best_test_bit_size_48]\n",
        "#         }\n",
        "# final_results = pd.DataFrame(data)\n",
        "\n",
        "\n",
        "# # Melt the dataframe to long format\n",
        "# df_melted = pd.melt(final_results, id_vars=['bit_size'], var_name='Metric', value_name='mAP')\n",
        "\n",
        "# # Create the bar plot\n",
        "# plt.figure(figsize=(12, 6))\n",
        "# sns.barplot(x='bit_size', y='mAP', hue='Metric', data=df_melted)\n",
        "\n",
        "# # Customize the plot\n",
        "# plt.title('T-Test')\n",
        "# plt.xlabel('Bit Size')\n",
        "# plt.ylabel('mAP')\n",
        "\n",
        "# # Add labels on top of each bar\n",
        "# for i in plt.gca().containers:\n",
        "#     plt.gca().bar_label(i, fmt='%.2f', label_type='edge')\n",
        "\n",
        "# # Adjust legend and layout\n",
        "# plt.legend(title='Metric', bbox_to_anchor=(1.05, 1))#, loc='upper left')\n",
        "# plt.tight_layout()\n",
        "\n",
        "# # Show the plot\n",
        "# plt.show()\n",
        "\n",
        "# data = {'bit_size':[8,16,32,48],\n",
        "#         'Valid': [best_valid_bit_size_8_mw, best_valid_bit_size_16_mw, best_valid_bit_size_32_mw, best_valid_bit_size_48_mw],\n",
        "#         'Test': [best_test_bit_size_8_mw, best_test_bit_size_16_mw, best_test_bit_size_32_mw, best_test_bit_size_48_mw]\n",
        "#         }\n",
        "# final_results_mw = pd.DataFrame(data)\n",
        "\n",
        "# # Melt the dataframe to long format\n",
        "# df_melted = pd.melt(final_results_mw, id_vars=['bit_size'], var_name='Metric', value_name='mAP')\n",
        "\n",
        "# # Create the bar plot\n",
        "# plt.figure(figsize=(12, 6))\n",
        "# sns.barplot(x='bit_size', y='mAP', hue='Metric', data=df_melted)\n",
        "\n",
        "# # Customize the plot\n",
        "# plt.title('MU-Test')\n",
        "# plt.xlabel('Bit Size')\n",
        "# plt.ylabel('mAP')\n",
        "\n",
        "# # Add labels on top of each bar\n",
        "# for i in plt.gca().containers:\n",
        "#     plt.gca().bar_label(i, fmt='%.2f', label_type='edge')\n",
        "\n",
        "# # Adjust legend and layout\n",
        "# plt.legend(title='Metric', bbox_to_anchor=(1.05, 1))\n",
        "# plt.tight_layout()\n",
        "\n",
        "# # Show the plot\n",
        "# plt.show()"
      ],
      "id": "9ebd8082",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.column-screen layout-ncol=2}\n",
        "\n",
        "![T-test curves](Compiled_results_Ttest.png)\n",
        "\n",
        "![MU-test curves](Compiled_results.png)\n",
        "\n",
        ":::\n"
      ],
      "id": "68acf29a"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "python3",
      "language": "python",
      "display_name": "Python 3 (ipykernel)",
      "path": "C:\\Users\\P307791\\Anaconda3\\share\\jupyter\\kernels\\python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}